#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

// Function to convert RGB to grayscale
void RGBtoGrayscale(unsigned char* RGB, unsigned char* Gray, int Width, int Height) {
    int Pixels = Width * Height;
    for(int i = 0; i < Pixels; i++) {
        int j = i * 3;
        Gray[i] = (unsigned char)(0.2989 * RGB[j] + 0.5870 * RGB[j + 1] + 0.1140 * RGB[j + 2]);
    }
}

// Function to apply Sobel filter and normalize the gradients
void SobelFilter(unsigned char* Gray, unsigned char* GxNormalized, unsigned char* GyNormalized, int Width, int Height) {
    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};
    int Gy[3][3] = {{-1, -2, -1}, {0, 0, 0}, {1, 2, 1}};
    int maxValX = 0, maxValY = 0;
    int* GradientX = new int[Width * Height];
    int* GradientY = new int[Width * Height];

    // Apply kernels to the image and find maximum gradient values for normalization
    for(int x = 1; x < Height - 1; x++) {
        for(int y = 1; y < Width - 1; y++) {
            int sumX = 0;
            int sumY = 0;

            // Apply kernels to the image
            for(int i = -1; i <= 1; i++) {
                for(int j = -1; j <= 1; j++) {
                    sumX += Gray[(x + i) * Width + (y + j)] * Gx[i + 1][j + 1];
                    sumY += Gray[(x + i) * Width + (y + j)] * Gy[i + 1][j + 1];
                }
            }

            // Store gradients
            GradientX[x * Width + y] = sumX;
            GradientY[x * Width + y] = sumY;

            // Update maximum values
            if(abs(sumX) > maxValX) {
                maxValX = abs(sumX);
            }
            if(abs(sumY) > maxValY) {
                maxValY = abs(sumY);
            }
        }
    }

    // Normalize the gradient values to 0-255 and store in output arrays
    for(int i = 0; i < Width * Height; i++) {
        GxNormalized[i] = (unsigned char)(255.0 * abs(GradientX[i]) / maxValX);
        GyNormalized[i] = (unsigned char)(255.0 * abs(GradientY[i]) / maxValY);
    }

    // Free allocated memory for temporary gradient arrays
    delete[] GradientX;
    delete[] GradientY;
}


int main(int argc, char *argv[]) {
    FILE *file;
    int Width = 481, Height = 321;

    if (argc < 4) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image_x_gradient.raw output_image_y_gradient.raw" << endl;
        return 0;
    }

    unsigned char* Imagedata = new unsigned char[Width * Height * 3];
    unsigned char* GrayData = new unsigned char[Width * Height];
    unsigned char* GradientX = new unsigned char[Width * Height];
    unsigned char* GradientY = new unsigned char[Width * Height];

    // Read image
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), Width * Height * 3, file);
    fclose(file);

    // Convert RGB to Grayscale
    RGBtoGrayscale(Imagedata, GrayData, Width, Height);

    // Apply Sobel Filter and Generate Gradient Images
    SobelFilter(GrayData, GradientX, GradientY, Width, Height);

    // Write Gradient X image data
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(GradientX, sizeof(unsigned char), Width * Height, file);
    fclose(file);

    // Write Gradient Y image data
    if (!(file = fopen(argv[3], "wb"))) {
        cout << "Cannot open file: " << argv[3] << endl;
        exit(1);
    }
    fwrite(GradientY, sizeof(unsigned char), Width * Height, file);
    fclose(file);

    // Free allocated memory
    delete[] Imagedata;
    delete[] GrayData;
    delete[] GradientX;
    delete[] GradientY;

    return 0;
}

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

// Function to convert RGB to grayscale
void RGBtoGrayscale(unsigned char* RGB, unsigned char* Gray, int Width, int Height) {
    int Pixels = Width * Height;
    for(int i = 0; i < Pixels; i++) {
        int j = i * 3;
        Gray[i] = (unsigned char)(0.2989 * RGB[j] + 0.5870 * RGB[j + 1] + 0.1140 * RGB[j + 2]);
    }
}

// Function to apply Sobel filter and normalize the gradient
void SobelFilter(unsigned char* Gray, unsigned char* Gradient, int Width, int Height) {
    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};
    int Gy[3][3] = {{-1, -2, -1}, {0, 0, 0}, {1, 2, 1}};
    int maxVal = 0;

    for(int x = 1; x < Height - 1; x++) {
        for(int y = 1; y < Width - 1; y++) {
            float sumX = 0.0;
            float sumY = 0.0;

            // Apply kernels to the image
            for(int i = -1; i <= 1; i++) {
                for(int j = -1; j <= 1; j++) {
                    sumX += Gray[(x + i) * Width + (y + j)] * Gx[i + 1][j + 1];
                    sumY += Gray[(x + i) * Width + (y + j)] * Gy[i + 1][j + 1];
                }
            }

            // Calculate the gradient magnitude
            unsigned char magnitude = (unsigned char)sqrt(pow(sumX, 2.0) + pow(sumY, 2.0));
            Gradient[x * Width + y] = magnitude;

            if(magnitude > maxVal) {
                maxVal = magnitude;
            }
        }
    }

    // Normalize the gradient to 0-255
    for(int i = 0; i < Width * Height; i++) {
        Gradient[i] = (Gradient[i] * 255) / maxVal;
    }
}

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int Width = 481, Height = 321;

    // Check for proper syntax
    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw" << endl;
        return 0;
    }

    // Allocate memory for image data array dynamically
    unsigned char* Imagedata = new unsigned char[Width * Height * 3]; // For RGB
    unsigned char* GrayData = new unsigned char[Width * Height]; // For grayscale
    unsigned char* Gradient = new unsigned char[Width * Height]; // For gradient

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), Width * Height * 3, file);
    fclose(file);

    // Convert RGB to Grayscale
    RGBtoGrayscale(Imagedata, GrayData, Width, Height);

    // Apply Sobel Filter
    SobelFilter(GrayData, Gradient, Width, Height);

    // Write Gradient image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(Gradient, sizeof(unsigned char), Width * Height, file);
    fclose(file);

    // Free allocated memory
    delete[] Imagedata;
    delete[] GrayData;
    delete[] Gradient;

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

// Function to convert RGB to grayscale
void RGBtoGrayscale(unsigned char* RGB, unsigned char* Gray, int Width, int Height) {
    int Pixels = Width * Height;
    for(int i = 0; i < Pixels; i++) {
        int j = i * 3;
        Gray[i] = (unsigned char)(0.2989 * RGB[j] + 0.5870 * RGB[j + 1] + 0.1140 * RGB[j + 2]);
    }
}
// funtion to apply thereshold
unsigned char findThreshold(unsigned char* Gradient, int Width, int Height, float percentile) {
    int histogram[256] = {0};
    int totalPixels = Width * Height;

    for (int i = 0; i < totalPixels; i++) {
        histogram[Gradient[i]]++;
    }

    int cumHistogram[256] = {0};
    cumHistogram[0] = histogram[0];
    for (int i = 1; i < 256; i++) {
        cumHistogram[i] = cumHistogram[i - 1] + histogram[i];
    }

    int target = int(percentile * totalPixels);
    for (int i = 0; i < 256; i++) {
        if (cumHistogram[i] >= target) {
            return i; 
        }
    }

    return 255; 
}
void Thresholding(unsigned char* Gradient, unsigned char* EdgeMap, int Width, int Height, unsigned char Threshold) {
    int Pixels = Width * Height;
    for (int i = 0; i < Pixels; i++) {
        EdgeMap[i] = (Gradient[i] >= Threshold) ? 255 : 0;
    }
}

// Function to apply Sobel filter and normalize the gradient
void SobelFilter(unsigned char* Gray, unsigned char* Gradient, int Width, int Height) {
    int Gx[3][3] = {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}};
    int Gy[3][3] = {{-1, -2, -1}, {0, 0, 0}, {1, 2, 1}};
    int maxVal = 0;

    for(int x = 1; x < Height - 1; x++) {
        for(int y = 1; y < Width - 1; y++) {
            float sumX = 0.0;
            float sumY = 0.0;

            // Apply kernels to the image
            for(int i = -1; i <= 1; i++) {
                for(int j = -1; j <= 1; j++) {
                    sumX += Gray[(x + i) * Width + (y + j)] * Gx[i + 1][j + 1];
                    sumY += Gray[(x + i) * Width + (y + j)] * Gy[i + 1][j + 1];
                }
            }

            // Calculate the gradient magnitude
            unsigned char magnitude = (unsigned char)sqrt(pow(sumX, 2.0) + pow(sumY, 2.0));
            Gradient[x * Width + y] = magnitude;

            if(magnitude > maxVal) {
                maxVal = magnitude;
            }
        }
    }

    // Normalize the gradient to 0-255
    for(int i = 0; i < Width * Height; i++) {
        Gradient[i] = (Gradient[i] * 255) / maxVal;
    }
}

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int Width = 481, Height = 321;

    // Check for proper syntax
    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw" << endl;
        return 0;
    }

    // Allocate memory for image data array dynamically
    unsigned char* Imagedata = new unsigned char[Width * Height * 3]; // For RGB
    unsigned char* GrayData = new unsigned char[Width * Height]; // For grayscale
    unsigned char* Gradient = new unsigned char[Width * Height]; // For gradient

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), Width * Height * 3, file);
    fclose(file);

    // Convert RGB to Grayscale
    RGBtoGrayscale(Imagedata, GrayData, Width, Height);

    // Apply Sobel Filter
    SobelFilter(GrayData, Gradient, Width, Height);
    
    unsigned char* EdgeMap = new unsigned char[Width * Height];

    float percentile = 0.90; // percentage threshold
    unsigned char Threshold = findThreshold(Gradient, Width, Height, percentile);

// apply the threshold
    Thresholding(Gradient, EdgeMap, Width, Height, Threshold);

    // Write Gradient image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(EdgeMap, sizeof(unsigned char), Width * Height, file);
    fclose(file);

    // Free allocated memory
    delete[] Imagedata;
    delete[] GrayData;
    delete[] Gradient;
    delete[] EdgeMap;
    return 0;
}


#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>

using namespace cv;
using namespace std;

int main(int argc, char** argv) {
    if (argc != 3) {
        cout << "error: inputfile + outputfile" << endl;
        return -1;
    }

    // read filenames
    char* inputFile = argv[1];
    char* outputFile = argv[2];

    Mat img = imread(inputFile, IMREAD_GRAYSCALE);

    if(img.empty()) {
        cout << "cannot open file " << inputFile << endl;
        return -1;
    }

    Mat edges;

    // use canny
    Canny(img, edges, 100, 250); 

    bool isSuccess = imwrite(outputFile, edges);
    if (!isSuccess) {
        cout << "fail to save: " << outputFile << endl;
        return -1;
    }

    cout << "process success, save to: " << outputFile << endl;

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel;
    int width = 750;
    int height = 500;
    int Threshold = 128;  //set the Threshold
    

    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }

    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
    }

    // Allocate image data array
    unsigned char* Imagedata = new unsigned char[width * height * BytesPerPixel]; 
    unsigned char* OutputImagedata = new unsigned char[width * height * BytesPerPixel];

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    // Apply fixed thresholding
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            for (int k = 0; k < BytesPerPixel; ++k) {
                int index = (i * width + j) * BytesPerPixel + k;
                OutputImagedata[index] = (Imagedata[index] < Threshold) ? 0 : 255;
            }
        }
    }


    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(OutputImagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 
#include <cstdlib> // for rand() and srand()
#include <ctime> 
using namespace std;

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    srand(time(NULL));

    FILE *file;
    int BytesPerPixel;
    int width = 750;
    int height = 500;
    int Threshold = 128;  //set the Threshold
    

    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }

    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
    }

    // Allocate image data array
    unsigned char* Imagedata = new unsigned char[width * height * BytesPerPixel]; 
    unsigned char* OutputImagedata = new unsigned char[width * height * BytesPerPixel];

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            for (int k = 0; k < BytesPerPixel; ++k) {
                int index = (i * width + j) * BytesPerPixel + k;
                int randomThreshold = rand() % 256; // Random threshold for each pixel
                OutputImagedata[index] = (Imagedata[index] > randomThreshold) ? 255 : 0;
            }
        }
    }

    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(OutputImagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 
#include <cstdlib> // for rand() and srand()
#include <ctime> 
#include <vector>

using namespace std;
std::vector<std::vector<int>> expandBayerMatrix(const std::vector<std::vector<int>>& I_n) {
    int n = I_n.size();
    std::vector<std::vector<int>> I_2n(2 * n, std::vector<int>(2 * n));

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            I_2n[i][j] = 4 * I_n[i][j] + 1;
            I_2n[i][j + n] = 4 * I_n[i][j] + 2;
            I_2n[i + n][j] = 4 * I_n[i][j] + 3;
            I_2n[i + n][j + n] = 4 * I_n[i][j];
        }
    }

    return I_2n;
}

std::vector<std::vector<int>> createThresholdMatrix(const std::vector<std::vector<int>>& I_n, int max_value = 255) {
    int N = I_n.size();
    std::vector<std::vector<int>> T(N, std::vector<int>(N));

    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            T[i][j] = static_cast<int>(((I_n[i][j] + 0.5) / (N * N)) * max_value);
        }
    }

    return T;
}

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    srand(time(NULL));

    FILE *file;
    int BytesPerPixel;
    int width = 750;
    int height = 500;
    int Threshold = 128;  //set the Threshold
    
    std::vector<std::vector<int>> I_2 = { {1, 2}, {3, 0} };
    std::vector<std::vector<int>> T_2 = createThresholdMatrix(I_2);

    std::vector<std::vector<int>> I_8 = expandBayerMatrix(expandBayerMatrix(I_2));
    std::vector<std::vector<int>> I_32 = expandBayerMatrix(expandBayerMatrix(I_8));

    std::vector<std::vector<int>> T_8 = createThresholdMatrix(I_8);
    std::vector<std::vector<int>> T_32 = createThresholdMatrix(I_32);

    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }

    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
    }

    // Allocate image data array
    unsigned char* Imagedata = new unsigned char[width * height * BytesPerPixel]; 
    unsigned char* OutputImagedata = new unsigned char[width * height * BytesPerPixel];

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    int N = T_2.size(); // Assuming we are using T_8, the 8x8 threshold matrix

    // Loop over each pixel and apply the Bayer dithering algorithm
    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            // Compute the corresponding position in the Bayer matrix
            int bayerRow = i % N;
            int bayerCol = j % N;
            // Dither based on the threshold matrix
            for (int k = 0; k < BytesPerPixel; ++k) {
                int index = (i * width + j) * BytesPerPixel + k;
                // If the pixel value is greater than the threshold, set it to 255, otherwise to 0
                OutputImagedata[index] = (Imagedata[index] > T_2[bayerRow][bayerCol]) ? 255 : 0;
            }
        }
    }

    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(OutputImagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel;
    int width = 750;
    int height = 500;
    int Threshold = 128;  //set the Threshold
    

    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }

    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
    }

    // Allocate image data array
    unsigned char* Imagedata = new unsigned char[width * height * BytesPerPixel]; 
    unsigned char* OutputImagedata = new unsigned char[width * height * BytesPerPixel];

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            int index = (i * width + j) * BytesPerPixel;
            int oldPixel = Imagedata[index];
            int newPixel = (oldPixel < Threshold) ? 0 : 255;
            OutputImagedata[index] = newPixel;
        
            int quant_error = oldPixel - newPixel;
        
            if (j + 1 < width) Imagedata[index + 1] += quant_error * 7 / 16;
            if (i + 1 < height) {
                if (j > 0) Imagedata[index + width - 1] += quant_error * 3 / 16;
                Imagedata[index + width] += quant_error * 5 / 16;
                if (j + 1 < width) Imagedata[index + width + 1] += quant_error * 1 / 16;
            }
        }
    }


    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(OutputImagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel;
    int width = 750;
    int height = 500;
    int Threshold = 128;  //set the Threshold
    

    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }

    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
    }

    // Allocate image data array
    unsigned char* Imagedata = new unsigned char[width * height * BytesPerPixel]; 
    unsigned char* OutputImagedata = new unsigned char[width * height * BytesPerPixel];

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            int index = (i * width + j) * BytesPerPixel;
            int oldPixel = Imagedata[index];
            int newPixel = (oldPixel < Threshold) ? 0 : 255;
            OutputImagedata[index] = newPixel;
        
            int quant_error = oldPixel - newPixel;

        // Spread the quant_error according to the JJN matrix
            if (j + 1 < width) Imagedata[index + 1] += quant_error * 7 / 48;
            if (j + 2 < width) Imagedata[index + 2] += quant_error * 5 / 48;
        
            if (i + 1 < height) {
                for (int m = -2; m <= 2; ++m) {
                    if (j + m >= 0 && j + m < width) {
                        int weight = (m == -2 || m == 2) ? 3 : (m == -1 || m == 1) ? 5 : 7;
                        Imagedata[index + width + m] += quant_error * weight / 48;
                    }
                }
            }

            if (i + 2 < height) {
                for (int n = -2; n <= 2; ++n) {
                    if (j + n >= 0 && j + n < width) {
                        int weight = (n == -2 || n == 2) ? 1 : (n == -1 || n == 1) ? 3 : 5;
                        Imagedata[index + 2 * width + n] += quant_error * weight / 48;
                    }
                }
            }
        }
    }

    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(OutputImagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h> 

using namespace std;

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel;
    int width = 750;
    int height = 500;
    int Threshold = 128;  //set the Threshold
    

    if (argc < 3) {
        cout << "Syntax Error - Incorrect Parameter Usage:" << endl;
        cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;
        return 0;
    }

    if (argc < 4) {
        BytesPerPixel = 1; // default is grey image
    } else {
        BytesPerPixel = atoi(argv[3]);
    }

    // Allocate image data array
    unsigned char* Imagedata = new unsigned char[width * height * BytesPerPixel]; 
    unsigned char* OutputImagedata = new unsigned char[width * height * BytesPerPixel];

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    fread(Imagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    for (int i = 0; i < height; ++i) {
        for (int j = 0; j < width; ++j) {
            int index = (i * width + j) * BytesPerPixel;
            int oldPixel = Imagedata[index];
            int newPixel = (oldPixel < Threshold) ? 0 : 255;
            OutputImagedata[index] = newPixel;
        
            int quant_error = oldPixel - newPixel;

        // Spread the quant_error according to the Stucki matrix
            if (j + 1 < width) Imagedata[index + 1] += quant_error * 8 / 42;
            if (j + 2 < width) Imagedata[index + 2] += quant_error * 4 / 42;
        
            for (int k = -2; k <= 2; ++k) {
                if (i + 1 < height && j + k >= 0 && j + k < width) {
                    int weight = (k == -2 || k == 2) ? 2 : (k == -1 || k == 1) ? 4 : 8;
                    Imagedata[index + width + k] += quant_error * weight / 42;
                }
                if (i + 2 < height && j + k >= 0 && j + k < width) {
                    int weight = (k == -2 || k == 2) ? 1 : (k == -1 || k == 1) ? 2 : 4;
                    Imagedata[index + 2 * width + k] += quant_error * weight / 42;
                }
            }
        }
    }
    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    fwrite(OutputImagedata, sizeof(unsigned char), width * height * BytesPerPixel, file);
    fclose(file);

    return 0;
}


#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;
unsigned char clip(const int value) {
    return (value < 0) ? 0 : (value > 255) ? 255 : (unsigned char)value;
}
// Function to perform Floyd-Steinberg dithering on a single channel
void FloydSteinbergDithering(unsigned char** channel, int height, int width) {
    int quant_error;
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            unsigned char oldPixel = channel[y][x];
            unsigned char newPixel = (oldPixel < 128) ? 0 : 255;
            channel[y][x] = newPixel;
            quant_error = oldPixel - newPixel;

            if (x+1 < width) channel[y][x+1] = clip(channel[y][x+1] + quant_error * 7 / 16);
            if (x-1 >= 0 && y+1 < height) channel[y+1][x-1] = clip(channel[y+1][x-1] + quant_error * 3 / 16);
            if (y+1 < height) channel[y+1][x] = clip(channel[y+1][x] + quant_error * 5 / 16);
            if (x+1 < width && y+1 < height) channel[y+1][x+1] = clip(channel[y+1][x+1] + quant_error * 1 / 16);
        }
    }
}

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel = 3; // Now we have 3 bytes per pixel, RGB format
    int Width = 500;
    int Height = 375;

    // Allocate image data array dynamically
    unsigned char*** Imagedata = new unsigned char**[Height];
    for (int i = 0; i < Height; ++i) {
        Imagedata[i] = new unsigned char*[Width];
        for (int j = 0; j < Width; ++j) {
            Imagedata[i][j] = new unsigned char[BytesPerPixel];
        }
    }

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    for (int i = 0; i < Height; ++i) {
        for (int j = 0; j < Width; ++j) {
            fread(Imagedata[i][j], sizeof(unsigned char), BytesPerPixel, file);
        }
    }
    fclose(file);

    unsigned char** channelC = new unsigned char*[Height];
    unsigned char** channelM = new unsigned char*[Height];
    unsigned char** channelY = new unsigned char*[Height];

    for (int i = 0; i < Height; ++i) {
        channelC[i] = new unsigned char[Width];
        channelM[i] = new unsigned char[Width];
        channelY[i] = new unsigned char[Width];

        for (int j = 0; j < Width; ++j) {
            // Convert RGB to CMY
            channelC[i][j] = 255 - Imagedata[i][j][0];
            channelM[i][j] = 255 - Imagedata[i][j][1];
            channelY[i][j] = 255 - Imagedata[i][j][2];
        }
    }

    // Perform Floyd-Steinberg dithering on each channel
    FloydSteinbergDithering(channelC, Height, Width);
    FloydSteinbergDithering(channelM, Height, Width);
    FloydSteinbergDithering(channelY, Height, Width);

    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    for (int i = 0; i < Height; ++i) {
        for (int j = 0; j < Width; ++j) {
            unsigned char rgbPixel[3]; // Array to hold RGB values
            // Convert dithered CMY back to RGB
            rgbPixel[0] = 255 - channelC[i][j]; // R
            rgbPixel[1] = 255 - channelM[i][j]; // G
            rgbPixel[2] = 255 - channelY[i][j]; // B

            // Write the RGB data
            fwrite(rgbPixel, sizeof(unsigned char), BytesPerPixel, file);
        }
    }
    fclose(file);

    // Deallocate image data array
    for (int i = 0; i < Height; ++i) {
        for (int j = 0; j < Width; ++j) {
            delete[] Imagedata[i][j];
        }
        delete[] Imagedata[i];
    }
    delete[] Imagedata;

    return 0;
}



#include <stdio.h>
#include <iostream>
#include <stdlib.h>

using namespace std;
unsigned char clip(const int value) {
    return (value < 0) ? 0 : (value > 255) ? 255 : (unsigned char)value;
}
enum MBVQ {
    CMYW, MYGC, RGMY, KRGB, RGBM, CMGB
};
struct Vertex {
    unsigned char R, G, B;
};

MBVQ pyramidMBVQ(unsigned char R, unsigned char G, unsigned char B) {
    if((R+G) > 255) {
        if((G+B) > 255) {
            if((R+G+B) > 510) return CMYW;
            else return MYGC;
        } else return RGMY;
    } else {
        if(!((G+B) > 255)) {
            if(!((R+G+B) > 255)) return KRGB;
            else return RGBM;
        } else return CMGB;
    }
}

void FindClosestVertex(MBVQ mbvq, unsigned char R, unsigned char G, unsigned char B, unsigned char &newR, unsigned char &newG, unsigned char &newB) {
    int distC=  abs(510 + R - G - B);
    int distM = abs(510 + G - R - B);
    int distG = abs(R + B + 255 - G);
    int distB = abs(R + 255 + G - B);
    int distR = abs(255 + G + B - R);
    int distK = abs(R + G + B);
    int distW = abs(765 - R - G - B);
    int distY = abs(510 + B - R - G);
    switch (mbvq) {
        case CMYW:
            if (distC < distM) {
                if (distC < distY) {
                    if(distC < distW){
                        newR = 0; newG = 255; newB = 255; //Cayon
                    } else{
                        newR = 255; newG = 255; newB = 255; //White
                    }
                } else {
                    if(distY < distW){
                        newR = 255; newG = 255; newB = 0;//yellow
                    } else{
                        newR = 255; newG = 255; newB = 255; //White
                    }
                }
            } else {
                if (distM < distY) {
                    if(distM < distW){
                        newR = 255; newG = 0; newB = 255; // Magenta
                    } else{
                        newR = 255; newG = 255; newB = 255; //White
                    }   
                } else {
                    if(distY < distW){
                        newR = 255; newG = 255; newB = 0; // Yellow
                    } else{
                        newR = 255; newG = 255; newB = 255; //White
                    }   
                }
            }
        break;

        case MYGC:
            if (distC < distM) {
                if (distC < distY) {
                    if(distC < distG){
                        newR = 0; newG = 255; newB = 255; //Cayon
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                } else {
                    if(distY < distG){
                        newR = 255; newG = 255; newB = 0; //yellow
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                }
            } else {
                if (distM < distY) {
                    if(distM < distG){
                        newR = 255; newG = 0; newB = 255; // Magenta
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                } else {
                    if(distY < distG){
                        newR = 255; newG = 255; newB = 0; // Yellow
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                }
            }
        break;

        case RGMY:
            if (distR < distM) {
                if (distR < distY) {
                    if(distR < distG){
                        newR = 255; newG = 0; newB = 0; //Red
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                } else {
                    if(distY < distG){
                        newR = 255; newG = 255; newB = 0;//yellow
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                }
            } else {
                if (distM < distY) {
                    if(distM < distG){
                        newR = 255; newG = 0; newB = 255; // Magenta
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                } else {
                    if(distY < distG){
                        newR = 255; newG = 255; newB = 0; // Yellow
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                }
            }
        break;

        case KRGB:
            if (distR < distK) {
                if (distR < distB) {
                    if(distR < distG){
                        newR = 255; newG = 0; newB = 0; //Red
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                } else {
                    if(distB < distG){
                        newR = 0; newG = 0; newB = 255;//Blue
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                }
            } else {
                if (distK < distB) {
                    if(distK < distG){
                        newR = 255; newG = 255; newB = 255; // Black
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                } else {
                    if(distB < distG){
                        newR = 0; newG = 0; newB = 255;//Blue
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                }
            }
        break;

        case RGBM:
            if (distR < distM) {
                if (distR < distB) {
                    if(distR < distG){
                        newR = 255; newG = 0; newB = 0; //Red
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                } else {
                    if(distB < distG){
                        newR = 0; newG = 0; newB = 255;//Blue
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                }
            } else {
                if (distM < distB) {
                    if(distM < distG){
                        newR = 255; newG = 0; newB = 255; // Magenta
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                } else {
                    if(distB < distG){
                        newR = 0; newG = 0; newB = 255;//Blue
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                }
            }
        break;

        case CMGB:
            if (distC < distM) {
                if (distC < distB) {
                    if(distC < distG){
                        newR = 0; newG = 255; newB = 255; //Cayon
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                } else {
                    if(distB < distG){
                        newR = 0; newG = 0; newB = 255;//Blue
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }
                }
            } else {
                if (distM < distB) {
                    if(distM < distG){
                        newR = 255; newG = 0; newB = 255; // Magenta
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                } else {
                    if(distB < distG){
                        newR = 0; newG = 0; newB = 255;//Blue
                    } else{
                        newR = 0; newG = 255; newB = 0; //Green
                    }   
                }
            }
            break;
    }
}

void FloydSteinbergDithering(unsigned char** channelR, unsigned char** channelG, unsigned char** channelB, int height, int width) {
    int quant_errorR, quant_errorG, quant_errorB;
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // Get the current pixel's RGB value
            unsigned char oldPixelR = channelR[y][x];
            unsigned char oldPixelG = channelG[y][x];
            unsigned char oldPixelB = channelB[y][x];

            // Determine the current pixel's MBVQ region
            MBVQ mbvq = pyramidMBVQ(oldPixelR, oldPixelG, oldPixelB);

            unsigned char newPixelR, newPixelG, newPixelB;
            FindClosestVertex(mbvq, oldPixelR, oldPixelG, oldPixelB, newPixelR, newPixelG, newPixelB);


            // Set the new pixel's value
            channelR[y][x] = newPixelR;
            channelG[y][x] = newPixelG;
            channelB[y][x] = newPixelB;

            // Calculate the quantization error for each color channel
            quant_errorR = oldPixelR - newPixelR;
            quant_errorG = oldPixelG - newPixelG;
            quant_errorB = oldPixelB - newPixelB;

            // Diffuse the quantization error to the neighboring pixels
            if (x + 1 < width) {
                channelR[y][x + 1] = clip(channelR[y][x + 1] + quant_errorR * 7 / 16);
                channelG[y][x + 1] = clip(channelG[y][x + 1] + quant_errorG * 7 / 16);
                channelB[y][x + 1] = clip(channelB[y][x + 1] + quant_errorB * 7 / 16);
            }
            if (x - 1 >= 0 && y + 1 < height) {
                channelR[y + 1][x - 1] = clip(channelR[y + 1][x - 1] + quant_errorR * 3 / 16);
                channelG[y + 1][x - 1] = clip(channelG[y + 1][x - 1] + quant_errorG * 3 / 16);
                channelB[y + 1][x - 1] = clip(channelB[y + 1][x - 1] + quant_errorB * 3 / 16);
            }
            if (y + 1 < height) {
                channelR[y + 1][x] = clip(channelR[y + 1][x] + quant_errorR * 5 / 16);
                channelG[y + 1][x] = clip(channelG[y + 1][x] + quant_errorG * 5 / 16);
                channelB[y + 1][x] = clip(channelB[y + 1][x] + quant_errorB * 5 / 16);
            }
            if (x + 1 < width && y + 1 < height) {
                channelR[y + 1][x + 1] = clip(channelR[y + 1][x + 1] + quant_errorR * 1 / 16);
                channelG[y + 1][x + 1] = clip(channelG[y + 1][x + 1] + quant_errorG * 1 / 16);
                channelB[y + 1][x + 1] = clip(channelB[y + 1][x + 1] + quant_errorB * 1 / 16);
            }
        }
    }
}

int main(int argc, char *argv[]) {
    // Define file pointer and variables
    FILE *file;
    int BytesPerPixel = 3; // Now we have 3 bytes per pixel, RGB format
    int Width = 500;
    int Height = 375;

    // Allocate image data array dynamically
    unsigned char*** Imagedata = new unsigned char**[Height];
    for (int i = 0; i < Height; ++i) {
        Imagedata[i] = new unsigned char*[Width];
        for (int j = 0; j < Width; ++j) {
            Imagedata[i][j] = new unsigned char[BytesPerPixel];
        }
    }

    // Read image (filename specified by first argument) into image data matrix
    if (!(file = fopen(argv[1], "rb"))) {
        cout << "Cannot open file: " << argv[1] << endl;
        exit(1);
    }
    for (int i = 0; i < Height; ++i) {
        for (int j = 0; j < Width; ++j) {
            fread(Imagedata[i][j], sizeof(unsigned char), BytesPerPixel, file);
        }
    }
    fclose(file);

    unsigned char** channelR = new unsigned char*[Height];
    unsigned char** channelG = new unsigned char*[Height];
    unsigned char** channelB = new unsigned char*[Height];

    for (int i = 0; i < Height; ++i) {
        channelR[i] = new unsigned char[Width];
        channelG[i] = new unsigned char[Width];
        channelB[i] = new unsigned char[Width];

        for (int j = 0; j < Width; ++j) {
            channelR[i][j] = clip(Imagedata[i][j][0]);
            channelG[i][j] = clip(Imagedata[i][j][1]);
            channelB[i][j] = clip(Imagedata[i][j][2]);
        }
    }

    // Perform Floyd-Steinberg dithering on each channel
    FloydSteinbergDithering(channelR,channelG,channelB, Height, Width);

    // Write image data (filename specified by second argument) from image data matrix
    if (!(file = fopen(argv[2], "wb"))) {
        cout << "Cannot open file: " << argv[2] << endl;
        exit(1);
    }
    for (int i = 0; i < Height; ++i) {
        for (int j = 0; j < Width; ++j) {
            unsigned char rgbPixel[3]; // Array to hold RGB values
            rgbPixel[0] = channelR[i][j]; // R
            rgbPixel[1] = channelG[i][j]; // G
            rgbPixel[2] = channelB[i][j]; // B

            // Write the RGB data
            fwrite(rgbPixel, sizeof(unsigned char), BytesPerPixel, file);
        }
    }
    fclose(file);

    // Deallocate image data array
    for (int i = 0; i < Height; ++i) {
        for (int j = 0; j < Width; ++j) {
            delete[] Imagedata[i][j];
        }
        delete[] Imagedata[i];
    }
    delete[] Imagedata;

    return 0;
}
